"""
PuckWorld Environment for OpenAI gym
The data used in this model comes from:
http://cs.stanford.edu/people/karpathy/reinforcejs/puckworld.html
Author: Qiang Ye
Date: July 17, 2017
"""

import math
import gym
from gym import spaces
from gym.utils import seeding
import numpy as np
import random

RAD2DEG = 57.29577951308232     # 弧度与角度换算关系1弧度=57.29..角度
# OBSTACLE_POS = [[24.5, 13.5], [22.8, 79.3], [41.4, 32.5], [26.4, 53.3], [70.5, 85.3], [89.2, 70.5], [78.2, 24.5], [69.4, 54.3]]
# OBSTACLE_RADIUS = [5, 8, 9.5, 2.5, 5, 4, 4.5, 6.5]
OBSTACLE_POS = [[38.5, 13.5], [9.5, 17.3], [36.2, 39.5], [12.4, 34.3]]
OBSTACLE_RADIUS = [2.5, 2.5, 2.5, 2.5]
DECRIE = 8e-4


class AvoidWorldEnv(gym.Env):
    metadata = {
        'render.modes': ['human', 'rgb_array'],
        'video.frames_per_second': 30
        }

    def __init__(self):
        self.width = 50            # 场景宽度 screen width
        self.height = 50           # 场景长度
        self.scale = 4.0
        self.max_surge = 2.0      # max agent velocity along a axis 
        self.max_yaw = 1.0
        self.detect_rad = 8.0
        self.min_obs_dis = 5.0
        self.usv_radius = 2.5
        # self.max_obs_dis = 10.0
        self.l_unit = 1.0

        # self.lambda_distance = 0.2
        # self.lambda_obstacle = 0.7
        self.usv_x_a = 15.0
        self.usv_y_a = 15.0
        self.target_x = 45.0
        self.target_y = 45.0

        self.usv_x_b = 15.0
        self.usv_y_b = 45.0

        self.done_a = False
        self.done_b = False

        self.t = 0                  # puck world clock
        self.total_step = 1200
#         self.control_out = 0
        # 作为观察空间每一个特征值的下限
        self.low = np.array([0,                     # 障碍 0 1
                            0,                      # surge 速度 0.0 ~ 2.0
                            -self.max_yaw,                      # yaw 速度 -1.0 ~ 1.0
                            0,                      # 距离目标距离 0.0 ~ 100 * math.sqrt(2)
                            -math.pi,                      # 距离目标角度（船圆心 极坐标）-pi ~ pi
                            0,                      # 弧度 船头角 （世界坐标）0 ~ 2 * pi
                            0,                       # done_a 
                            0,                    # 距离障碍最短距离（含圆心）已经碰撞 0 ~ 8.0, 障碍船头角与自身船头角相对角度(弧度)， 障碍速度角与自身船头角相对角度（弧度）
                            0,  0,  0,  0,  0,                   
                            0,  0,  0,  0,  0,       # 180度 十个探测位
                            0,                     # 障碍 0 1
                            0,                      # surge 速度 0.0 ~ 2.0
                            -self.max_yaw,                      # yaw 速度 -1.0 ~ 1.0
                            0,                      # 距离目标距离 0.0 ~ 100 * math.sqrt(2)
                            -math.pi,                      # 距离目标角度（船圆心 极坐标）-pi ~ pi
                            0,                      # 弧度 船头角 （世界坐标）0 ~ 2 * pi
                            0,                       # done_b
                            0,                    # 距离障碍最短距离（含圆心）已经碰撞 0 ~ 8.0, 障碍船头角与自身船头角相对角度(弧度)， 障碍速度角与自身船头角相对角度（弧度）
                            0,  0,  0,  0,  0,                  
                            0,  0,  0,  0,  0     # 180度 十个探测位
                            ])   

        self.high = np.array([1,       
                            self.max_surge,
                            self.max_yaw,          
                            100.0 * math.sqrt(2),
                            math.pi,    
                            2 * math.pi,   
                            1,
                            self.detect_rad,       # 5 + 5    
                            self.detect_rad, self.detect_rad, self.detect_rad, self.detect_rad, self.detect_rad,
                            self.detect_rad, self.detect_rad, self.detect_rad, self.detect_rad, self.detect_rad,                    
                            1,       
                            self.max_surge,
                            self.max_yaw,          
                            100.0 * math.sqrt(2),
                            math.pi,    
                            2 * math.pi,   
                            1,
                            self.detect_rad,      # 5 + 5    
                            self.detect_rad, self.detect_rad, self.detect_rad, self.detect_rad, self.detect_rad,
                            self.detect_rad, self.detect_rad, self.detect_rad, self.detect_rad, self.detect_rad
                            ])  

        self.reward = 0         # for rendering
        self.action = None      # for rendering
        self.viewer = None
        
        # discrete   ---------------------------------  
        self.list_acc_surge = np.linspace(-0.5, 0.5, 3)
        self.list_acc_yaw = np.linspace(-0.25, 0.25, 3)
        self.action_space = spaces.MultiDiscrete([3, 3, 3, 3])  
        # discrete   ---------------------------------  
        
        # continuous  ---------------------------------------- 
#         self.action_low = np.array([-0.5, -0.45])
#         self.action_high = np.array([0.5, 0.45])
#         self.action_space = spaces.Box(self.action_low, self.action_high, dtype = np.float16)
        # continuous  ---------------------------------------- 
    
        self.observation_space = spaces.Box(self.low, self.high, dtype = np.float32)    

        self._seed()    # 产生一个随机数种子
        self.reset()

    def _seed(self, seed=None):
        # 产生一个随机化时需要的种子，同时返回一个np_random对象，支持后续的随机化生成操作
        self.np_random, seed = seeding.np_random(seed)  
        return [seed]

    # def _get_cross_dis(cx, cy, r, stx, sty, edx, edy):
    def _get_cross_dis(self, cx, cy, r, stx, sty, edx, edy):
        if edx != stx:
            k = (edy - sty) / (edx - stx)
            b = edy - k * edx

            # (1 + k ^ 2) * x ^ 2 - x * (2 * cx - 2 * k * (b - cy)) + cx * cx + (b - cy) * (b - cy) - r * r = 0

            c = cx * cx + (b - cy) * (b- cy) -r * r
            a = (1 + k * k)
            b1 = (2 * cx - 2 * k * (b - cy))
            # a*x^2 - b1*x + c = 0
            
            if b1 * b1 - 4 * a * c >= 0:
                tmp = math.sqrt(b1 * b1 - 4 * a * c)
                x1 = (b1 + tmp) / (2 * a)
                y1 = k * x1 + b
                x2 = (b1 - tmp) / (2 * a)
                y2 = k * x2 + b
                dis_1 = self._compute_dis(edx - x1, edy - y1)
                dis_2 = self._compute_dis(edx - x2, edy - y2)   # stx sty 即是船头点
                return min(dis_1, dis_2, self.detect_rad)
            else:
                return self.detect_rad
        else:
            if r * r - (stx - cx) * (stx - cx) >= 0:
                tmp = math.sqrt(r * r - (stx - cx) * (stx - cx))
                x1 = stx
                y1 = cy + tmp
                x2 = stx
                y2 = cy - tmp
                dis_1 = self._compute_dis(edx - x1, edy - y1)
                dis_2 = self._compute_dis(edx - x2, edy - y2)
                return min(dis_1, dis_2, self.detect_rad)
            else:
                return self.detect_rad

    def step(self, action):
        assert self.action_space.contains(action), \
            "%r (%s) invalid" % (action, type(action))
              
        # discrete   ---------------------------------  
        acc_surge_num_a, acc_yaw_num_a, acc_surge_num_b, acc_yaw_num_b = action 
        acc_surge_a = self.list_acc_surge[acc_surge_num_a]
        acc_yaw_a = self.list_acc_yaw[acc_yaw_num_a]
        acc_surge_b = self.list_acc_surge[acc_surge_num_b]
        acc_yaw_b = self.list_acc_yaw[acc_yaw_num_b]
        # discrete   --------------------------------- 

        # is_obstacle_a, velocity_surge_a, velocity_yaw_a, target_distance_a, target_radian_a, ahead_radian_a, _ = 0, 0, 0, 0, 0, 0, 0
        # is_obstacle_b, velocity_surge_b, velocity_yaw_b, target_distance_b, target_radian_b, ahead_radian_b = 0, 0, 0, 0, 0, 0
        
        is_obstacle_a, velocity_surge_a, velocity_yaw_a, target_distance_a, target_radian_a, ahead_radian_a, done_a, ob0, ob1, ob2, ob3, ob4, ob5, ob6, ob7, ob8, ob9, ob10,\
        is_obstacle_b, velocity_surge_b, velocity_yaw_b, target_distance_b, target_radian_b, ahead_radian_b, done_b, ab0, ab1, ab2, ab3, ab4, ab5, ab6, ab7, ab8, ab9, ab10 = self.state # 获取agent位置，速度，目标位置

        old_target_distance_a = target_distance_a
        old_is_obstacle_a = is_obstacle_a
        old_sum_ob_a = ob0 + ob1 + ob2 + ob3 + ob4 + ob5 + ob6 + ob7 + ob8 + ob9 + ob10

        old_target_distance_b = target_distance_b
        old_is_obstacle_b = is_obstacle_b
        old_sum_ob_b = ab0 + ab1 + ab2 + ab3 + ab4 + ab5 + ab6 + ab7 + ab8 + ab9 + ab10

        self.reward = 0.0
        self.t += 1

        if self.done_a == False:
            velocity_x_a = velocity_surge_a * math.cos(ahead_radian_a)
            velocity_y_a = velocity_surge_a * math.sin(ahead_radian_a)
            self.usv_x_a, self.usv_y_a = self.usv_x_a + velocity_x_a, self.usv_y_a + velocity_y_a         # update agent position
            ahead_radian_a = ahead_radian_a + velocity_yaw_a
            if ahead_radian_a < 0.0: ahead_radian_a = ahead_radian_a + 2 * math.pi
            if ahead_radian_a > 2 * math.pi: ahead_radian_a = ahead_radian_a - 2 * math.pi

            velocity_surge_a = velocity_surge_a + acc_surge_a
            if velocity_surge_a < 0.0: velocity_surge_a = 0.0
            if velocity_surge_a > self.max_surge: velocity_surge_a = self.max_surge
            velocity_yaw_a = velocity_yaw_a + acc_yaw_a
            if velocity_yaw_a < - self.max_yaw: velocity_yaw_a = - self.max_yaw
            if velocity_yaw_a > self.max_yaw: velocity_yaw_a = self.max_yaw

            target_distance_a = self._compute_dis(self.usv_x_a - self.target_x, self.usv_y_a - self.target_y)     # agent to target
            target_radian_a = math.atan2(self.target_y - self.usv_y_a, self.target_x - self.usv_x_a)

            obstacle_a = [self.detect_rad for a in range(11)]

            is_crash_a = False
            for i, num in zip(range(-5, 6), range(11)):
                usv_ray_x_a = self.usv_x_a + self.usv_radius * math.cos(math.pi / 10.0 * i + ahead_radian_a)
                usv_ray_y_a = self.usv_y_a + self.usv_radius * math.sin(math.pi / 10.0 * i + ahead_radian_a)
                for obstacle_cir, obstalce_rad in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
                    cur_dis = self._get_cross_dis(obstacle_cir[0], obstacle_cir[1], obstalce_rad, self.usv_x_a, self.usv_y_a, usv_ray_x_a, usv_ray_y_a)
                    obstacle_a[num] = min(obstacle_a[num], cur_dis)
                dynamic_dis = self._get_cross_dis(self.usv_x_b, self.usv_y_b, 2.5, self.usv_x_a, self.usv_y_a, usv_ray_x_a, usv_ray_y_a)
                if dynamic_dis < obstacle_a[num]:
                    obstacle_a[num] = dynamic_dis

            is_obstacle_a = bool(min(obstacle_a) < self.detect_rad)  
            # print(obstacle)
            is_crash_a = bool(min(obstacle_a) < 0.1) 

            self.done_a = bool(target_distance_a <= self.min_obs_dis or is_crash_a or self.t > self.total_step)   
            if is_crash_a:
                self.reward += - 1.0 - target_distance_a / 15
            if target_distance_a <= self.min_obs_dis:
                self.reward += 1 + 500 / self.t
            if self.t > self.total_step:
                self.reward += 1 - target_distance_a / 15 
            dense_reward = 0.0
            if is_obstacle_a == 0 and target_distance_a < old_target_distance_a:
                dense_reward += 1
            sum_ob = sum(obstacle_a)
            if is_obstacle_a == 1 and old_is_obstacle_a == 1 and sum_ob > old_sum_ob_a:
                dense_reward += 1
            if is_obstacle_a == 0 and old_is_obstacle_a == 1:
                dense_reward += 1
            self.reward = self.reward + DECRIE * dense_reward
        else:
            is_obstacle_a, velocity_surge_a, velocity_yaw_a, target_distance_a, target_radian_a, ahead_radian_a = 0, 0, 0, 0, 0, 0
            obstacle_a = [self.detect_rad for a in range(11)]
            self.usv_x_a, self.usv_y_a = self.target_x, self.target_y


        if self.done_b == False:
            velocity_x_b = velocity_surge_b * math.cos(ahead_radian_b)
            velocity_y_b = velocity_surge_b * math.sin(ahead_radian_b)
            self.usv_x_b, self.usv_y_b = self.usv_x_b + velocity_x_b, self.usv_y_b + velocity_y_b         # update agent position
            ahead_radian_b = ahead_radian_b + velocity_yaw_b
            if ahead_radian_b < 0.0: ahead_radian_b = ahead_radian_b + 2 * math.pi
            if ahead_radian_b > 2 * math.pi: ahead_radian_b = ahead_radian_b - 2 * math.pi

            velocity_surge_b = velocity_surge_b + acc_surge_b
            if velocity_surge_b < 0.0: velocity_surge_b = 0.0
            if velocity_surge_b > self.max_surge: velocity_surge_b = self.max_surge
            velocity_yaw_b = velocity_yaw_b + acc_yaw_b
            if velocity_yaw_b < - self.max_yaw: velocity_yaw_b = - self.max_yaw
            if velocity_yaw_b > self.max_yaw: velocity_yaw_b = self.max_yaw

            target_distance_b = self._compute_dis(self.usv_x_b - self.target_x, self.usv_y_b - self.target_y)     # agent to target
            target_radian_b = math.atan2(self.target_y - self.usv_y_b, self.target_x - self.usv_x_b)

            obstacle_b = [self.detect_rad for a in range(11)]

            is_crash_b = False
            for i, num in zip(range(-5, 6), range(11)):
                usv_ray_x_b = self.usv_x_b + self.usv_radius * math.cos(math.pi / 10.0 * i + ahead_radian_b)
                usv_ray_y_b = self.usv_y_b + self.usv_radius * math.sin(math.pi / 10.0 * i + ahead_radian_b)
                for obstacle_cir, obstalce_rad in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
                    cur_dis = self._get_cross_dis(obstacle_cir[0], obstacle_cir[1], obstalce_rad, self.usv_x_b, self.usv_y_b, usv_ray_x_b, usv_ray_y_b)
                    obstacle_b[num] = min(obstacle_b[num], cur_dis)
                dynamic_dis = self._get_cross_dis(self.usv_x_a, self.usv_y_a, 2.5, self.usv_x_b, self.usv_y_b, usv_ray_x_b, usv_ray_y_b)
                if dynamic_dis < obstacle_b[num]:
                    obstacle_b[num] = dynamic_dis

            is_obstacle_b = bool(min(obstacle_b) < self.detect_rad)  
            is_crash_b = bool(min(obstacle_b) < 0.1)

            self.done_b = bool(target_distance_b <= self.min_obs_dis or is_crash_b or self.t > self.total_step)   
            if is_crash_b:
                self.reward += - 1.0 - target_distance_b / 15
            if target_distance_b <= self.min_obs_dis:
                self.reward += 1 + 500 / self.t
            if self.t > self.total_step:
                self.reward += 1 - target_distance_b / 15

            dense_reward = 0.0
            if is_obstacle_b == 0 and target_distance_b < old_target_distance_b:
                dense_reward += 1
            sum_ob = sum(obstacle_b)
            if is_obstacle_b == 1 and old_is_obstacle_b == 1 and sum_ob > old_sum_ob_b:
                dense_reward += 1
            if is_obstacle_b == 0 and old_is_obstacle_b == 1:
                dense_reward += 1
            self.reward = self.reward + DECRIE * dense_reward
        else:
            is_obstacle_b, velocity_surge_b, velocity_yaw_b, target_distance_b, target_radian_b, ahead_radian_b = 0, 0, 0, 0, 0, 0  
            obstacle_b = [self.detect_rad for a in range(11)]
            self.usv_x_b, self.usv_y_b = self.target_x, self.target_y
        done = self.done_a or self.done_b

        self.state = (is_obstacle_a, velocity_surge_a, velocity_yaw_a, target_distance_a, target_radian_a, ahead_radian_a, self.done_a, obstacle_a[0], obstacle_a[1],
        obstacle_a[2], obstacle_a[3], obstacle_a[4], obstacle_a[5], 
        obstacle_a[6], obstacle_a[7], obstacle_a[8], obstacle_a[9], obstacle_a[10], 
        is_obstacle_b, velocity_surge_b, velocity_yaw_b, target_distance_b, target_radian_b, ahead_radian_b, self.done_b, obstacle_b[0], obstacle_b[1],
        obstacle_b[2], obstacle_b[3], obstacle_b[4], obstacle_b[5],
        obstacle_b[6], obstacle_b[7], obstacle_b[8], obstacle_b[9], obstacle_b[10])
        return np.array(self.state), self.reward, done, {0:self.usv_x_a, 1:self.usv_y_a, 2:self.usv_x_b, 3:self.usv_y_b}

    def _random_pos(self):
        return random.randint(0, self.width), random.randint(0, self.height)

    def _compute_dis(self, dx, dy):
        return math.sqrt(math.pow(dx,2) + math.pow(dy,2))

    def _is_valied(self, cur_x, cur_y, test_list):
        for pos, radius in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
            if self._compute_dis(pos[0] - cur_x, pos[1] - cur_y) <= 3.0 + 2.5 + radius:   # not too close to the obstacle
                return False
        for tl in test_list:
            if self._compute_dis(cur_x - tl[0], cur_y - tl[1]) <= 3.0 + self.usv_radius + self.usv_radius:   # not too close to the obstacle
                return False
        return True

    def reset(self):
        test_list = []
        cur_x, cur_y = self._random_pos()
        while self._is_valied(cur_x, cur_y, test_list) is not True:
            cur_x, cur_y = self._random_pos()
        self.usv_x_a, self.usv_y_a = cur_x, cur_x
        test_list.append([cur_x, cur_y])

        cur_x, cur_y = self._random_pos()
        while self._is_valied(cur_x, cur_y, test_list) is not True:
            cur_x, cur_y = self._random_pos()
        self.target_x, self.target_y = cur_x, cur_y
        test_list.append([cur_x, cur_y])

        cur_x, cur_y = self._random_pos()
        while self._is_valied(cur_x, cur_y, test_list) is not True:
            cur_x, cur_y = self._random_pos()
        self.usv_x_b, self.usv_y_b = cur_x, cur_x
        test_list.append([cur_x, cur_y])

        self.t = 0
        self.done_a = False
        self.done_b = False
#         self.control_out = 0

        target_distance_a = self._compute_dis(self.target_x - self.usv_x_a, self.target_y - self.usv_y_a)
        target_radian_a = math.atan2(self.target_y - self.usv_y_a, self.target_x - self.usv_x_a)

        ahead_radian_a = random.random() * math.pi * 2

        target_distance_b = self._compute_dis(self.target_x - self.usv_x_b, self.target_y - self.usv_y_b)
        target_radian_b = math.atan2(self.target_y - self.usv_y_b, self.target_x - self.usv_x_b)

        ahead_radian_b = random.random() * math.pi * 2

        obstacle_a = [self.detect_rad for a in range(11)]

        is_crash_a = False
        for i, num in zip(range(-5, 6), range(11)):
            usv_ray_x_a = self.usv_x_a + self.usv_radius * math.cos(math.pi / 10.0 * i + ahead_radian_a)
            usv_ray_y_a = self.usv_y_a + self.usv_radius * math.sin(math.pi / 10.0 * i + ahead_radian_a)
            for obstacle_cir, obstalce_rad in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
                cur_dis = self._get_cross_dis(obstacle_cir[0], obstacle_cir[1], obstalce_rad, self.usv_x_a, self.usv_y_a, usv_ray_x_a, usv_ray_y_a)
                obstacle_a[num] = min(obstacle_a[num], cur_dis)
            dynamic_dis = self._get_cross_dis(self.usv_x_b, self.usv_y_b, 2.5, self.usv_x_a, self.usv_y_a, usv_ray_x_a, usv_ray_y_a)
            if dynamic_dis < obstacle_a[num]:
                obstacle_a[num] = dynamic_dis

        is_obstacle_a = bool(min(obstacle_a) < self.detect_rad)  
        # print(obstacle)
        is_crash_a = bool(min(obstacle_a) < 0.1) 

        ##==========================================

        obstacle_b = [self.detect_rad for a in range(11)]

        is_crash_b = False
        for i, num in zip(range(-5, 6), range(11)):
            usv_ray_x_b = self.usv_x_b + self.usv_radius * math.cos(math.pi / 10.0 * i + ahead_radian_b)
            usv_ray_y_b = self.usv_y_b + self.usv_radius * math.sin(math.pi / 10.0 * i + ahead_radian_b)
            for obstacle_cir, obstalce_rad in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
                cur_dis = self._get_cross_dis(obstacle_cir[0], obstacle_cir[1], obstalce_rad, self.usv_x_b, self.usv_y_b, usv_ray_x_b, usv_ray_y_b)
                obstacle_b[num] = min(obstacle_b[num], cur_dis)
            dynamic_dis = self._get_cross_dis(self.usv_x_a, self.usv_y_a, 2.5, self.usv_x_b, self.usv_y_b, usv_ray_x_b, usv_ray_y_b)
            if dynamic_dis < obstacle_b[num]:
                obstacle_b[num] = dynamic_dis

        is_obstacle_b = bool(min(obstacle_b) < self.detect_rad)  
        # print(obstacle)
        is_crash_b = bool(min(obstacle_b) < 0.1) 


        self.state = np.array([is_obstacle_a, 0.0, 0.0, target_distance_a, target_radian_a, ahead_radian_a, self.done_a, obstacle_a[0], obstacle_a[1],
        obstacle_a[2], obstacle_a[3], obstacle_a[4], obstacle_a[5],
        obstacle_a[6], obstacle_a[7], obstacle_a[8], obstacle_a[9], obstacle_a[10], 
        is_obstacle_b, 0.0, 0.0, target_distance_b, target_radian_b, ahead_radian_b, self.done_b, obstacle_b[0], obstacle_b[1],
        obstacle_b[2], obstacle_b[3], obstacle_b[4], obstacle_b[5],
        obstacle_b[6], obstacle_b[7], obstacle_b[8], obstacle_b[9], obstacle_b[10]])
        return self.state  # np.array(self.state)


    def render(self, mode='human', close=False):
        if close:
            if self.viewer is not None:
                self.viewer.close()
                self.viewer = None
            return

        # 如果还没有设定屏幕对象，则初始化整个屏幕具备的元素。
        if self.viewer is None:
            from gym.envs.classic_control import rendering
            self.viewer = rendering.Viewer(self.width * self.scale, self.height * self.scale)

            # 在Viewer里绘制一个几何图像的步骤如下：
            # 1. 建立该对象需要的数据本身
            # 2. 使用rendering提供的方法返回一个geom对象
            # 3. 对geom对象进行一些对象颜色、线宽、线型、变换属性的设置（有些对象提供一些个
            #    性化的方法
            #    来设置属性，具体请参考继承自这些Geom的对象），这其中有一个重要的属性就是
            #    变换属性，该属性负责对对象在屏幕中的位置、渲染、缩放进行渲染。如果某对象
            #    在呈现时可能发生上述变化，则应建立关于该对象的变换属性。该属性是一个
            #    Transform对象，而一个Transform对象，包括translate、rotate和scale
            #    三个属性，每个属性都由以np.array对象描述的矩阵决定。
            # 4. 将新建立的geom对象添加至viewer的绘制对象列表里，如果在屏幕上只出现一次，
            #    将其加入到add_onegeom(）列表中，如果需要多次渲染，则将其加入add_geom()
            # 5. 在渲染整个viewer之前，对有需要的geom的参数进行修改，修改主要基于该对象
            #    的Transform对象
            # 6. 调用Viewer的render()方法进行绘制

            target = rendering.make_circle(2.5 * self.scale, 30, True)
            target.set_color(101.0 / 255.0, 147.0 / 255.0, 74.0 / 255.0)
            self.viewer.add_geom(target)
            # target_circle = rendering.make_circle(2.5, 30, False)
            # target_circle.set_color(178.0 / 255.0, 200.0 / 255.0, 187.0 / 255.0)
            # self.viewer.add_geom(target_circle)
            self.target_trans = rendering.Transform()
            target.add_attr(self.target_trans)
            # target_circle.add_attr(self.target_trans)

            self.agent_a = rendering.make_circle(2.5 * self.scale, 30, True)
            self.agent_a.set_color(178.0 / 255.0, 200.0 / 255.0, 187.0 / 255.0)
            self.viewer.add_geom(self.agent_a)
            self.agent_trans_a = rendering.Transform()
            self.agent_a.add_attr(self.agent_trans_a)

            self.agent_b = rendering.make_circle(2.5 * self.scale, 30, True)
            self.agent_b.set_color(175.0 / 255.0, 215.0 / 255.0, 237.0 / 255.0)
            self.viewer.add_geom(self.agent_b)
            self.agent_trans_b = rendering.Transform()
            self.agent_b.add_attr(self.agent_trans_b)

            for obstacles_pos, radius in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
                obstacle = rendering.make_circle(radius * self.scale, 30, True)
                obstacle.set_color(252.0 / 255.0, 157.0 / 255.0, 154.0 / 255.0)
                self.viewer.add_geom(obstacle)
                self.obstacle_trans = rendering.Transform(translation=(obstacles_pos[0] * self.scale, obstacles_pos[1] * self.scale))
                obstacle.add_attr(self.obstacle_trans)

            
        self.target_trans.set_translation(self.target_x * self.scale, self.target_y * self.scale)
        self.agent_trans_a.set_translation(self.usv_x_a * self.scale, self.usv_y_a * self.scale)
        self.agent_trans_b.set_translation(self.usv_x_b * self.scale, self.usv_y_b * self.scale)
        
        return self.viewer.render(return_rgb_array = mode == 'rgb_array')


if __name__ =="__main__":
    env = AvoidWorldEnv()
    print("hello")
    env.reset()
    nfs = env.observation_space.shape[0]
    nfa = env.action_space
    # print("nfs:%s; nfa:d"%(nfs))
    # print(env.observation_space)
    # print(env.action_space)
    total_r = 0
    for _ in range(10000):
        env.render() 
        s, r, d, _ = env.step(env.action_space.sample())
        total_r += r
        if d is True:
            env.close() 
            env.reset()
            print("total reward is  {}".format(total_r))
            total_r = 0
       

    print("env closed")