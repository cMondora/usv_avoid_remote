"""
PuckWorld Environment for OpenAI gym
The data used in this model comes from:
http://cs.stanford.edu/people/karpathy/reinforcejs/puckworld.html
Author: Qiang Ye
Date: July 17, 2017
"""

import math
import gym
from gym import spaces
from gym.utils import seeding
import numpy as np
import random

RAD2DEG = 57.29577951308232     # 弧度与角度换算关系1弧度=57.29..角度
OBSTACLE_POS = [[24.5, 13.5], [22.8, 79.3], [41.4, 32.5], [26.4, 53.3], [70.5, 85.3], [89.2, 70.5], [78.2, 24.5], [69.4, 54.3]]
OBSTACLE_RADIUS = [5, 8, 9.5, 2.5, 5, 4, 4.5, 6.5]
# DECRIE = 8e-3


class AvoidWorldEnv(gym.Env):
    metadata = {
        'render.modes': ['human', 'rgb_array'],
        'video.frames_per_second': 30
        }

    def __init__(self):
        self.width = 100            # 场景宽度 screen width
        self.height = 100           # 场景长度
        self.scale = 4.0
        self.max_surge = 2.0      # max agent velocity along a axis 
        self.max_yaw = 1.0
        self.detect_rad = 8.0
        self.min_obs_dis = 5.0
        self.usv_radius = 2.5
        # self.max_obs_dis = 10.0
        self.l_unit = 1.0

        # self.lambda_distance = 0.2
        # self.lambda_obstacle = 0.7
        self.usv_x = 15.0
        self.usv_y = 15.0
        self.target_x = 85.0
        self.target_y = 85.0
        
        self.t = 0                  # puck world clock
        self.total_step = 1200
#         self.control_out = 0
        # 作为观察空间每一个特征值的下限
        self.low = np.array([0,                     # 障碍 0 1
                            0,                      # surge 速度 0.0 ~ 2.0
                            -self.max_yaw,                      # yaw 速度 -1.0 ~ 1.0
                            0,                      # 距离目标距离 0.0 ~ 100 * math.sqrt(2)
                            -math.pi,                      # 距离目标角度（船圆心 极坐标）-pi ~ pi
                            0,                      # 弧度 船头角 （世界坐标）0 ~ 2 * pi
                            0,                      # 距离障碍最短距离（含圆心）已经碰撞 0 ~ 8.0
                            0,  0,  0,  0,  0,                   
                            0,  0,  0,  0,  0        # 180度 十个探测位
                            ])   
        self.high = np.array([1,       
                            self.max_surge,
                            self.max_yaw,          
                            100.0 * math.sqrt(2),
                            math.pi,    
                            2 * math.pi,   
                            self.detect_rad,         # 5 + 5    
                            self.detect_rad,  self.detect_rad,  self.detect_rad,  self.detect_rad,  self.detect_rad,
                            self.detect_rad,  self.detect_rad,  self.detect_rad,  self.detect_rad,  self.detect_rad                     
                            ])  

        self.reward = 0         # for rendering
        self.action = None      # for rendering
        self.viewer = None
        
        # discrete   ---------------------------------  
        self.list_acc_surge = np.linspace(-0.5, 0.5, 3)
        self.list_acc_yaw = np.linspace(-0.5, 0.5, 5)
        self.action_space = spaces.MultiDiscrete([3, 5])  
        # discrete   ---------------------------------  
        
        # continuous  ---------------------------------------- 
#         self.action_low = np.array([-0.5, -0.45])
#         self.action_high = np.array([0.5, 0.45])
#         self.action_space = spaces.Box(self.action_low, self.action_high, dtype = np.float16)
        # continuous  ---------------------------------------- 
    
        self.observation_space = spaces.Box(self.low, self.high, dtype = np.float32)    

        self._seed()    # 产生一个随机数种子
        self.reset()

    def _seed(self, seed=None):
        # 产生一个随机化时需要的种子，同时返回一个np_random对象，支持后续的随机化生成操作
        self.np_random, seed = seeding.np_random(seed)  
        return [seed]

    # def _get_cross_dis(cx, cy, r, stx, sty, edx, edy):
    def _get_cross_dis(self, cx, cy, r, stx, sty, edx, edy):
        if edx != stx:
            k = (edy - sty) / (edx - stx)
            b = edy - k * edx

            # (1 + k ^ 2) * x ^ 2 - x * (2 * cx - 2 * k * (b - cy)) + cx * cx + (b - cy) * (b - cy) - r * r = 0

            c = cx * cx + (b - cy) * (b- cy) -r * r
            a = (1 + k * k)
            b1 = (2 * cx - 2 * k * (b - cy))
            # a*x^2 - b1*x + c = 0
            
            if b1 * b1 - 4 * a * c >= 0:
                tmp = math.sqrt(b1 * b1 - 4 * a * c)
                x1 = (b1 + tmp) / (2 * a)
                y1 = k * x1 + b
                x2 = (b1 - tmp) / (2 * a)
                y2 = k * x2 + b
                dis_1 = self._compute_dis(edx - x1, edy - y1)
                dis_2 = self._compute_dis(edx - x2, edy - y2)   # stx sty 即是船头点
                return min(dis_1, dis_2, self.detect_rad)
            else:
                return self.detect_rad
        else:
            if r * r - (stx - cx) * (stx - cx) >= 0:
                tmp = math.sqrt(r * r - (stx - cx) * (stx - cx))
                x1 = stx
                y1 = cy + tmp
                x2 = stx
                y2 = cy - tmp
                dis_1 = self._compute_dis(edx - x1, edy - y1)
                dis_2 = self._compute_dis(edx - x2, edy - y2)
                return min(dis_1, dis_2, self.detect_rad)
            else:
                return self.detect_rad

    def step(self, action):
        assert self.action_space.contains(action), \
            "%r (%s) invalid" % (action, type(action))
        
          # continuous  ----------------------------------------
        
#         acc_surge, acc_yaw = action[0], action[1]    # action for rendering
#         if acc_surge >= -0.5 and acc_surge < -0.5 + 1.0 / 3.0: acc_surge = -0.5
#         elif acc_surge >= -0.5 + 1.0 / 3.0 and acc_surge < 0.5 - 1.0 / 3.0: acc_surge = 0.0
#         elif acc_surge >= 0.5 - 1.0 / 3.0 and acc_surge <= 0.5: acc_surge = 0.5
        
#         if acc_yaw >= -0.45 and acc_yaw < -0.35: acc_yaw = -0.4
#         elif acc_yaw >= -0.35 and acc_yaw < -0.25: acc_yaw = -0.3
#         elif acc_yaw >= -0.25 and acc_yaw < -0.15: acc_yaw = -0.2
#         elif acc_yaw >= -0.15 and acc_yaw < -0.05: acc_yaw = -0.1
#         elif acc_yaw >= -0.05 and acc_yaw < 0.05: acc_yaw = 0.0
#         elif acc_yaw >= 0.05 and acc_yaw < 0.15: acc_yaw = 0.1
#         elif acc_yaw >= 0.15 and acc_yaw < 0.25: acc_yaw = 0.2
#         elif acc_yaw >= 0.25 and acc_yaw < 0.35: acc_yaw = 0.3
#         elif acc_yaw >= 0.35 and acc_yaw < 0.45: acc_yaw = 0.4
            
          # continuous  ---------------------------------------- 
        
        
        # discrete   ---------------------------------  
        acc_surge_num, acc_yaw_num = action 
        acc_surge = self.list_acc_surge[acc_surge_num]
        acc_yaw = self.list_acc_yaw[acc_yaw_num]
        # discrete   --------------------------------- 
        
        is_obstacle, velocity_surge, velocity_yaw, target_distance, target_radian, ahead_radian, ob0, ob1, ob2, ob3, ob4, ob5, ob6, ob7, ob8, ob9, ob10 = self.state # 获取agent位置，速度，目标位置

        velocity_x = velocity_surge * math.cos(ahead_radian)
        velocity_y = velocity_surge * math.sin(ahead_radian)
        self.usv_x, self.usv_y = self.usv_x + velocity_x, self.usv_y + velocity_y         # update agent position
        ahead_radian = ahead_radian + velocity_yaw
        if ahead_radian < 0.0: ahead_radian = ahead_radian + 2 * math.pi
        if ahead_radian > 2 * math.pi: ahead_radian = ahead_radian - 2 * math.pi

        velocity_surge = velocity_surge + acc_surge
        if velocity_surge < 0.0: velocity_surge = 0.0
        if velocity_surge > self.max_surge: velocity_surge = self.max_surge
        velocity_yaw = velocity_yaw + acc_yaw
        if velocity_yaw < - self.max_yaw: velocity_yaw = - self.max_yaw
        if velocity_yaw > self.max_yaw: velocity_yaw = self.max_yaw
        
        self.t += 1
        self.control_out = self.control_out + bool(acc_surge) + bool(acc_yaw)
        # if self.t % self.update_time == 0:  # update target position
        #     tx = self._random_pos()         # randomly
        #     ty = self._random_pos()

        target_distance = self._compute_dis(self.usv_x - self.target_x, self.usv_y - self.target_y)     # agent to target
        target_radian = math.atan2(self.target_y - self.usv_y, self.target_x - self.usv_x)

        obstacle = [self.detect_rad for a in range(11)]

        is_crash = False
        for i, num in zip(range(-5, 6), range(11)):
            usv_ray_x = self.usv_x + self.usv_radius * math.cos(math.pi / 10.0 * i + ahead_radian)
            usv_ray_y = self.usv_y + self.usv_radius * math.sin(math.pi / 10.0 * i + ahead_radian)
            for obstacle_cir, obstalce_rad in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
                cur_dis = self._get_cross_dis(obstacle_cir[0], obstacle_cir[1], obstalce_rad, self.usv_x, self.usv_y, usv_ray_x, usv_ray_y)
                obstacle[num] = min(obstacle[num], cur_dis)

        is_obstacle = bool(min(obstacle) < self.detect_rad)  
        # print(obstacle)
        is_crash = bool(min(obstacle) < 0.1)    
        self.reward = 0.0

        done = bool(target_distance <= self.min_obs_dis or is_crash or self.t > self.total_step)   
        if is_crash:
            self.reward = - 1.0 - target_distance / 15
#             self.reward -= DECRIE * self.control_out / self.t
        if target_distance <= self.min_obs_dis:
            self.reward = 1 + 500 / self.t
#             self.reward -= DECRIE * self.control_out / self.t
        if self.t > self.total_step:
            self.reward = 1 - target_distance / 15
#             self.reward -= DECRIE * self.control_out / self.t
        
        self.state = (is_obstacle, velocity_surge, velocity_yaw, target_distance, target_radian, ahead_radian, obstacle[0], obstacle[1], obstacle[2], obstacle[3], obstacle[4], obstacle[5],
        obstacle[6], obstacle[7], obstacle[8], obstacle[9], obstacle[10])
        return np.array(self.state), self.reward, done, {0:self.usv_x, 1:self.usv_y}

    def _random_pos(self):
        return random.randint(0, self.width), random.randint(0, self.height)

    def _compute_dis(self, dx, dy):
        return math.sqrt(math.pow(dx,2) + math.pow(dy,2))

    def _is_valied(self, cur_x, cur_y, is_target = True):
        if is_target:
            for pos, radius in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
                if self._compute_dis(pos[0] - cur_x, pos[1] - cur_y) <= 3.0 + 2.5 + radius:   # not too close to the obstacle
                    return False
            if self._compute_dis(self.target_x - cur_x, self.target_y - cur_y) <= 3.0 + 2.5 + radius:
                return False
            return True
        else:
            for pos, radius in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
                if self._compute_dis(pos[0] - cur_x, pos[1] - cur_y) <= 3.0 + 2.5 + radius:
                    return False
            return True

    def reset(self):
        cur_x, cur_y = self._random_pos()
        while self._is_valied(cur_x, cur_y, False) is not True:
            cur_x, cur_y = self._random_pos()
        self.usv_x, self.usv_y = cur_x, cur_y

        cur_x, cur_y = self._random_pos()
        while self._is_valied(cur_x, cur_y) is not True:
            cur_x, cur_y = self._random_pos()
        self.target_x, self.target_y = cur_x, cur_y
        self.t = 0
#         self.control_out = 0

        target_distance = self._compute_dis(self.target_x - self.usv_x, self.target_y - self.usv_y)
        target_radian = math.atan2(self.target_y - self.usv_y, self.target_x - self.usv_x)

        ahead_radian = random.random() * math.pi * 2

        usv_head_x = self.usv_x + self.usv_radius * math.cos(ahead_radian)
        usv_head_y = self.usv_y + self.usv_radius * math.sin(ahead_radian)

        is_obstacle = False
        obstacle = [self.detect_rad for a in range(11)]

        for i, ob_dis in zip(range(-5, 6), obstacle):
            usv_ray_x = usv_head_x + math.cos(math.pi / 10.0 * i + ahead_radian)
            usv_ray_y = usv_head_y + math.sin(math.pi / 10.0 * i + ahead_radian)
            for obstacle_cir, obstalce_rad in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
                cur_dis = self._get_cross_dis(obstacle_cir[0], obstacle_cir[1], obstalce_rad, usv_head_x, usv_head_y, usv_ray_x, usv_ray_y)
                ob_dis = min(ob_dis, cur_dis)

        is_obstacle = bool(min(obstacle) < self.detect_rad)


        self.state = np.array([ is_obstacle,
                                0.0,
                                0.0,
                                target_distance,
                                target_radian,
                                ahead_radian,
                                obstacle[0], obstacle[1], obstacle[2], obstacle[3], obstacle[4], obstacle[5],
                                obstacle[6], obstacle[7], obstacle[8], obstacle[9], obstacle[10]
                               ])
        return self.state  # np.array(self.state)


    def render(self, mode='human', close=False):
        if close:
            if self.viewer is not None:
                self.viewer.close()
                self.viewer = None
            return

        # 如果还没有设定屏幕对象，则初始化整个屏幕具备的元素。
        if self.viewer is None:
            from gym.envs.classic_control import rendering
            self.viewer = rendering.Viewer(self.width * self.scale, self.height * self.scale)

            # 在Viewer里绘制一个几何图像的步骤如下：
            # 1. 建立该对象需要的数据本身
            # 2. 使用rendering提供的方法返回一个geom对象
            # 3. 对geom对象进行一些对象颜色、线宽、线型、变换属性的设置（有些对象提供一些个
            #    性化的方法
            #    来设置属性，具体请参考继承自这些Geom的对象），这其中有一个重要的属性就是
            #    变换属性，该属性负责对对象在屏幕中的位置、渲染、缩放进行渲染。如果某对象
            #    在呈现时可能发生上述变化，则应建立关于该对象的变换属性。该属性是一个
            #    Transform对象，而一个Transform对象，包括translate、rotate和scale
            #    三个属性，每个属性都由以np.array对象描述的矩阵决定。
            # 4. 将新建立的geom对象添加至viewer的绘制对象列表里，如果在屏幕上只出现一次，
            #    将其加入到add_onegeom(）列表中，如果需要多次渲染，则将其加入add_geom()
            # 5. 在渲染整个viewer之前，对有需要的geom的参数进行修改，修改主要基于该对象
            #    的Transform对象
            # 6. 调用Viewer的render()方法进行绘制

            target = rendering.make_circle(2.5 * self.scale, 30, True)
            target.set_color(178.0 / 255.0, 200.0 / 255.0, 187.0 / 255.0)
            self.viewer.add_geom(target)
            # target_circle = rendering.make_circle(2.5, 30, False)
            # target_circle.set_color(178.0 / 255.0, 200.0 / 255.0, 187.0 / 255.0)
            # self.viewer.add_geom(target_circle)
            self.target_trans = rendering.Transform()
            target.add_attr(self.target_trans)
            # target_circle.add_attr(self.target_trans)

            self.agent = rendering.make_circle(2.5 * self.scale, 30, True)
            self.agent.set_color(222.0 / 255.0, 211.0 / 255.0, 140.0 / 255.0)
            self.viewer.add_geom(self.agent)
            self.agent_trans = rendering.Transform()
            self.agent.add_attr(self.agent_trans)

            for obstacles_pos, radius in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
                obstacle = rendering.make_circle(radius * self.scale, 30, True)
                obstacle.set_color(252.0 / 255.0, 157.0 / 255.0, 154.0 / 255.0)
                self.viewer.add_geom(obstacle)
                self.obstacle_trans = rendering.Transform(translation=(obstacles_pos[0] * self.scale, obstacles_pos[1] * self.scale))
                obstacle.add_attr(self.obstacle_trans)

            
        self.target_trans.set_translation(self.target_x * self.scale, self.target_y * self.scale)
        self.agent_trans.set_translation(self.usv_x * self.scale, self.usv_y * self.scale)
        
        return self.viewer.render(return_rgb_array = mode == 'rgb_array')


if __name__ =="__main__":
    env = AvoidWorldEnv()
    print("hello")
    env.reset()
    nfs = env.observation_space.shape[0]
    nfa = env.action_space
    # print("nfs:%s; nfa:d"%(nfs))
    # print(env.observation_space)
    # print(env.action_space)

    for _ in range(10000):
       env.render()
       s, r, d, _ = env.step(env.action_space.sample())
       if d is True:
           env.reset()

    print("env closed")