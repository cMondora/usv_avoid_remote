"""
PuckWorld Environment for OpenAI gym
The data used in this model comes from:
http://cs.stanford.edu/people/karpathy/reinforcejs/puckworld.html
Author: Qiang Ye
Date: July 17, 2017
"""

import math
import gym
from gym import spaces
from gym.utils import seeding
import numpy as np
import random

RAD2DEG = 57.29577951308232     # 弧度与角度换算关系1弧度=57.29..角度
OBSTACLE_POS = [[31.5, 13.5], [9.5, 17.3], [26.2, 32.5]]
OBSTACLE_RADIUS = [2, 2, 2]
# DECRIE = 8e-3


class AvoidWorldEnv(gym.Env):
    metadata = {
        'render.modes': ['human', 'rgb_array'],
        'video.frames_per_second': 30
        }

    def __init__(self):
        self.width = 40            # 场景宽度 screen width
        self.height = 40           # 场景长度
        self.scale = 4.0
        self.max_surge = 2.0      # max agent velocity along a axis 
        self.max_yaw = 1.0
        self.detect_rad = 8.0
        self.min_obs_dis = 4.0
        self.usv_radius = 2
        # self.max_obs_dis = 10.0
        self.l_unit = 1.0

        # self.lambda_distance = 0.2
        # self.lambda_obstacle = 0.7
        self.usv_x_m = 15.0
        self.usv_y_m = 15.0
        self.usv_x_n = 35.5
        self.usv_y_n = 15.5
        self.target_x = 35.0
        self.target_y = 35.0
        
        self.t = 0                  # puck world clock
        self.t_m = 0
        self.t_n = 0
        self.total_step = 400
#         self.control_out = 0
        # 作为观察空间每一个特征值的下限
        self.low = np.array([0,                 # 是否有障碍
                            0,                      # surge 速度 0.0 ~ 2.0
                            -self.max_yaw,                      # yaw 速度 -1.0 ~ 1.0
                            0,                      # 距离目标距离 0.0 ~ 100 * math.sqrt(2)
                            -math.pi,                      # 距离目标角度（船圆心 极坐标）-pi ~ pi
                            0,                      # 弧度 船头角 （世界坐标）0 ~ 2 * pi
                            0,                    # 距离障碍最短距离（含圆心）已经碰撞 0 ~ 8.0, 
                            0,  0,  0,  0,  0,                   
                            0,  0,  0,  0,  0, 
                            0,
                            0,                      # surge 速度 0.0 ~ 2.0
                            -self.max_yaw,                      # yaw 速度 -1.0 ~ 1.0
                            0,                      # 距离目标距离 0.0 ~ 100 * math.sqrt(2)
                            -math.pi,                      # 距离目标角度（船圆心 极坐标）-pi ~ pi
                            0,                      # 弧度 船头角 （世界坐标）0 ~ 2 * pi
                            0,                    # 距离障碍最短距离（含圆心）已经碰撞 0 ~ 8.0, 
                            0,  0,  0,  0,  0,                   
                            0,  0,  0,  0,  0
                            ])   
        self.high = np.array([1,
                            self.max_surge,
                            self.max_yaw,          
                            self.height * math.sqrt(2),
                            math.pi,    
                            2 * math.pi,
                            self.detect_rad,       # 5 + 5    
                            self.detect_rad, self.detect_rad, self.detect_rad, self.detect_rad, self.detect_rad,
                            self.detect_rad, self.detect_rad, self.detect_rad, self.detect_rad, self.detect_rad, 
                            1,
                            self.max_surge,
                            self.max_yaw,          
                            self.height * math.sqrt(2),
                            math.pi,    
                            2 * math.pi,
                            self.detect_rad,       # 5 + 5    
                            self.detect_rad, self.detect_rad, self.detect_rad, self.detect_rad, self.detect_rad,
                            self.detect_rad, self.detect_rad, self.detect_rad, self.detect_rad, self.detect_rad                                      
                            ])  

        self.reward = 0         # for rendering
        self.action = None      # for rendering
        self.viewer = None
        
        # discrete   ---------------------------------  
        self.list_acc_surge = np.linspace(-0.5, 0.5, 3)
        self.list_acc_yaw = np.linspace(-0.25, 0.25, 3)
        self.action_space = spaces.MultiDiscrete([3, 3, 3, 3])  
        # discrete   ---------------------------------  
        
        # continuous  ---------------------------------------- 
#         self.action_low = np.array([-0.5, -0.45])
#         self.action_high = np.array([0.5, 0.45])
#         self.action_space = spaces.Box(self.action_low, self.action_high, dtype = np.float16)
        # continuous  ---------------------------------------- 
    
        self.observation_space = spaces.Box(self.low, self.high, dtype = np.float32)    

        self._seed()    # 产生一个随机数种子
        self.reset()

    def _seed(self, seed=None):
        # 产生一个随机化时需要的种子，同时返回一个np_random对象，支持后续的随机化生成操作
        self.np_random, seed = seeding.np_random(seed)  
        return [seed]

    # def _get_cross_dis(cx, cy, r, stx, sty, edx, edy):
    def _get_cross_dis(self, cx, cy, r, stx, sty, edx, edy):
        if edx != stx:
            k = (edy - sty) / (edx - stx)
            b = edy - k * edx

            # (1 + k ^ 2) * x ^ 2 - x * (2 * cx - 2 * k * (b - cy)) + cx * cx + (b - cy) * (b - cy) - r * r = 0

            c = cx * cx + (b - cy) * (b- cy) -r * r
            a = (1 + k * k)
            b1 = (2 * cx - 2 * k * (b - cy))
            # a*x^2 - b1*x + c = 0
            
            if b1 * b1 - 4 * a * c >= 0:
                tmp = math.sqrt(b1 * b1 - 4 * a * c)
                x1 = (b1 + tmp) / (2 * a)
                y1 = k * x1 + b
                x2 = (b1 - tmp) / (2 * a)
                y2 = k * x2 + b
                dis_1 = self._compute_dis(edx - x1, edy - y1)
                dis_2 = self._compute_dis(edx - x2, edy - y2)   # stx sty 即是船头点
                return min(dis_1, dis_2, self.detect_rad)
            else:
                return self.detect_rad
        else:
            if r * r - (stx - cx) * (stx - cx) >= 0:
                tmp = math.sqrt(r * r - (stx - cx) * (stx - cx))
                x1 = stx
                y1 = cy + tmp
                x2 = stx
                y2 = cy - tmp
                dis_1 = self._compute_dis(edx - x1, edy - y1)
                dis_2 = self._compute_dis(edx - x2, edy - y2)
                return min(dis_1, dis_2, self.detect_rad)
            else:
                return self.detect_rad

    def step(self, action):
        assert self.action_space.contains(action), \
            "%r (%s) invalid" % (action, type(action))
        
        
        # discrete   ---------------------------------  
        acc_surge_num_m, acc_yaw_num_m, acc_surge_num_n, acc_yaw_num_n = action 
        acc_surge_m = self.list_acc_surge[acc_surge_num_m]
        acc_yaw_m = self.list_acc_yaw[acc_yaw_num_m]
        acc_surge_n = self.list_acc_surge[acc_surge_num_n]
        acc_yaw_n = self.list_acc_yaw[acc_yaw_num_n]
        # discrete   --------------------------------- 

        is_obstacle_m, velocity_surge_m, velocity_yaw_m, target_distance_m, target_radian_m, ahead_radian_m, ob0, ob1, ob2, ob3, ob4, ob5, ob6, ob7, ob8, ob9, ob10, \
        is_obstacle_n, velocity_surge_n, velocity_yaw_n, target_distance_n, target_radian_n, ahead_radian_n, ab0, ab1, ab2, ab3, ab4, ab5, ab6, ab7, ab8, ab9, ab10 = self.state # 获取agent位置，速度，目标位置

        ###  =========================================================

        velocity_x_m = velocity_surge_m * math.cos(ahead_radian_m)
        velocity_y_m = velocity_surge_m * math.sin(ahead_radian_m)
        self.usv_x_m, self.usv_y_m = self.usv_x_m + velocity_x_m, self.usv_y_m + velocity_y_m         # update agent position
        ahead_radian_m = ahead_radian_m + velocity_yaw_m
        if ahead_radian_m < 0.0: ahead_radian_m = ahead_radian_m + 2 * math.pi
        if ahead_radian_m > 2 * math.pi: ahead_radian_m = ahead_radian_m - 2 * math.pi

        velocity_surge_m = velocity_surge_m + acc_surge_m
        if velocity_surge_m < 0.0: velocity_surge_m = 0.0
        if velocity_surge_m > self.max_surge: velocity_surge_m = self.max_surge
        velocity_yaw_m = velocity_yaw_m + acc_yaw_m
        if velocity_yaw_m < - self.max_yaw: velocity_yaw_m = - self.max_yaw
        if velocity_yaw_m > self.max_yaw: velocity_yaw_m = self.max_yaw
        target_distance_m = self._compute_dis(self.usv_x_m - self.target_x, self.usv_y_m - self.target_y)     # agent to target
        target_radian_m = math.atan2(self.target_y - self.usv_y_m, self.target_x - self.usv_x_m)
        
        obstacle_m = [self.detect_rad for a in range(11)]
        is_crash_m = False
        for i, num in zip(range(-5, 6), range(11)):
            usv_ray_x_m = self.usv_x_m + self.usv_radius * math.cos(math.pi / 10.0 * i + ahead_radian_m)
            usv_ray_y_m = self.usv_y_m + self.usv_radius * math.sin(math.pi / 10.0 * i + ahead_radian_m)
            for obstacle_cir, obstalce_rad in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
                cur_dis = self._get_cross_dis(obstacle_cir[0], obstacle_cir[1], obstalce_rad, self.usv_x_m, self.usv_y_m, usv_ray_x_m, usv_ray_y_m)
                obstacle_m[num] = min(obstacle_m[num], cur_dis)
            dynamic_dis = self._get_cross_dis(self.usv_x_n, self.usv_y_n, self.usv_radius, self.usv_x_m, self.usv_y_m, usv_ray_x_m, usv_ray_y_m)
            if dynamic_dis < obstacle_m[num]:
                obstacle_m[num] = dynamic_dis

        is_obstacle_m = bool(min(obstacle_m) < self.detect_rad)
        is_crash_m = bool(min(obstacle_m) < 0.1)
        ###  =========================================================


        velocity_x_n = velocity_surge_n * math.cos(ahead_radian_n)
        velocity_y_n = velocity_surge_n * math.sin(ahead_radian_n)
        self.usv_x_n, self.usv_y_n = self.usv_x_n + velocity_x_n, self.usv_y_n + velocity_y_n         # update agent position
        ahead_radian_n = ahead_radian_n + velocity_yaw_n
        if ahead_radian_n < 0.0: ahead_radian_n = ahead_radian_n + 2 * math.pi
        if ahead_radian_n > 2 * math.pi: ahead_radian_n = ahead_radian_n - 2 * math.pi

        velocity_surge_n = velocity_surge_n + acc_surge_n
        if velocity_surge_n < 0.0: velocity_surge_n = 0.0
        if velocity_surge_n > self.max_surge: velocity_surge_n = self.max_surge
        velocity_yaw_n = velocity_yaw_n + acc_yaw_n
        if velocity_yaw_n < - self.max_yaw: velocity_yaw_n = - self.max_yaw
        if velocity_yaw_n > self.max_yaw: velocity_yaw_n = self.max_yaw
        target_distance_n = self._compute_dis(self.usv_x_n - self.target_x, self.usv_y_n - self.target_y)     # agent to target
        target_radian_n = math.atan2(self.target_y - self.usv_y_n, self.target_x - self.usv_x_n)

        obstacle_n = [self.detect_rad for a in range(11)]
        is_crash_n = False
        for i, num in zip(range(-5, 6), range(11)):
            usv_ray_x_n = self.usv_x_n + self.usv_radius * math.cos(math.pi / 10.0 * i + ahead_radian_n)
            usv_ray_y_n = self.usv_y_n + self.usv_radius * math.sin(math.pi / 10.0 * i + ahead_radian_n)
            for obstacle_cir, obstalce_rad in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
                cur_dis = self._get_cross_dis(obstacle_cir[0], obstacle_cir[1], obstalce_rad, self.usv_x_n, self.usv_y_n, usv_ray_x_n, usv_ray_y_n)
                obstacle_n[num] = min(obstacle_n[num], cur_dis)
            dynamic_dis = self._get_cross_dis(self.usv_x_m, self.usv_y_m, self.usv_radius, self.usv_x_n, self.usv_y_n, usv_ray_x_n, usv_ray_y_n)
            if dynamic_dis < obstacle_n[num]:
                obstacle_n[num] = dynamic_dis

        is_obstacle_n = bool(min(obstacle_n) < self.detect_rad)
        is_crash_n = bool(min(obstacle_n) < 0.1)
        ###  =========================================================
        
        self.t += 1

        done = bool(self.t > self.total_step)   

        self.reward = 0.0

        if target_distance_m <= self.min_obs_dis:
            mins_t = self.t - self.t_m
            self.t_m = self.t
            self.reward = 1 + 500 / mins_t
            test_list = [(self.usv_x_n, self.usv_y_n), (self.target_x, self.target_y)]
            cur_x, cur_y = self._random_pos()
            while self._is_valied(cur_x, cur_y, test_list) is not True:
                cur_x, cur_y = self._random_pos()
            self.usv_x_m, self.usv_y_m = cur_x, cur_y
        if target_distance_n <= self.min_obs_dis:
            mins_t = self.t - self.t_n
            self.t_n = self.t
            self.reward = 1 + 500 / mins_t
            test_list = [(self.usv_x_m, self.usv_y_m), (self.target_x, self.target_y)]
            cur_x, cur_y = self._random_pos()
            while self._is_valied(cur_x, cur_y, test_list) is not True:
                cur_x, cur_y = self._random_pos()
            self.usv_x_n, self.usv_y_n = cur_x, cur_y
        if is_crash_m:
            self.reward = -10.0
            test_list = [(self.usv_x_n, self.usv_y_n), (self.target_x, self.target_y)]
            cur_x, cur_y = self._random_pos()
            while self._is_valied(cur_x, cur_y, test_list) is not True:
                cur_x, cur_y = self._random_pos()
            self.usv_x_m, self.usv_y_m = cur_x, cur_y
        if is_crash_n:
            self.reward = -10.0
            test_list = [(self.usv_x_m, self.usv_y_m), (self.target_x, self.target_y)]
            cur_x, cur_y = self._random_pos()
            while self._is_valied(cur_x, cur_y, test_list) is not True:
                cur_x, cur_y = self._random_pos()
            self.usv_x_n, self.usv_y_n = cur_x, cur_y
        
        self.state = (is_obstacle_m, velocity_surge_m, velocity_yaw_m, target_distance_m, target_radian_m, ahead_radian_m, obstacle_m[0], obstacle_m[1], 
        obstacle_m[2], obstacle_m[3], obstacle_m[4], obstacle_m[5], 
        obstacle_m[6], obstacle_m[7], obstacle_m[8], obstacle_m[9], obstacle_m[10], 
        is_obstacle_n, velocity_surge_n, velocity_yaw_n, target_distance_n, target_radian_n, ahead_radian_n, obstacle_n[0], obstacle_n[1],
        obstacle_n[2], obstacle_n[3], obstacle_n[4], obstacle_n[5],
        obstacle_n[6], obstacle_n[7], obstacle_n[8], obstacle_n[9], obstacle_n[10])
        return np.array(self.state), self.reward, done, {0:self.usv_x_m, 1:self.usv_y_m, 2:self.usv_x_n, 3:self.usv_y_n}

    def _random_pos(self):
        return random.randint(0, self.width), random.randint(0, self.height)

    def _compute_dis(self, dx, dy):
        return math.sqrt(math.pow(dx,2) + math.pow(dy,2))

    def _is_valied(self, cur_x, cur_y, test_list):
        for pos, radius in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
            if self._compute_dis(pos[0] - cur_x, pos[1] - cur_y) <= 3.0 + self.usv_radius + radius:   # not too close to the obstacle
                return False
        for tl in test_list:
            if self._compute_dis(tl[0] - cur_x, tl[1] - cur_y) <= 3.0 + self.usv_radius + self.usv_radius:
                return False
        return True

    def reset(self):
        test_list = []
        cur_x, cur_y = self._random_pos()
        while self._is_valied(cur_x, cur_y, test_list) is not True:
            cur_x, cur_y = self._random_pos()
        self.usv_x_m, self.usv_y_m = cur_x, cur_y
        test_list.append([self.usv_x_m, self.usv_y_m])

        cur_x, cur_y =self._random_pos()
        while self._is_valied(cur_x, cur_y, test_list) is not True:
            cur_x, cur_y = self._random_pos()
        self.usv_x_n, self.usv_y_n = cur_x, cur_y
        test_list.append([self.usv_x_n, self.usv_y_n])

        cur_x, cur_y = self._random_pos()
        while self._is_valied(cur_x, cur_y, test_list) is not True:
            cur_x, cur_y = self._random_pos()
        self.target_x, self.target_y = cur_x, cur_y
        self.t = 0
        self.t_m = 0
        self.t_n = 0
#         self.control_out = 0

        #===================
        target_distance_m = self._compute_dis(self.target_x - self.usv_x_m, self.target_y - self.usv_y_m)
        target_radian_m = math.atan2(self.target_y - self.usv_y_m, self.target_x - self.usv_x_m)
        ahead_radian_m = random.random() * math.pi * 2

        obstacle_m = [self.detect_rad for a in range(11)]
        is_crash_m = False
        for i, num in zip(range(-5, 6), range(11)):
            usv_ray_x_m = self.usv_x_m + self.usv_radius * math.cos(math.pi / 10.0 * i + ahead_radian_m)
            usv_ray_y_m = self.usv_y_m + self.usv_radius * math.sin(math.pi / 10.0 * i + ahead_radian_m)
            for obstacle_cir, obstalce_rad in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
                cur_dis = self._get_cross_dis(obstacle_cir[0], obstacle_cir[1], obstalce_rad, self.usv_x_m, self.usv_y_m, usv_ray_x_m, usv_ray_y_m)
                obstacle_m[num] = min(obstacle_m[num], cur_dis)
            dynamic_dis = self._get_cross_dis(self.usv_x_n, self.usv_y_n, self.usv_radius, self.usv_x_m, self.usv_y_m, usv_ray_x_m, usv_ray_y_m)
            if dynamic_dis < obstacle_m[num]:
                obstacle_m[num] = dynamic_dis

        is_obstacle_m = bool(min(obstacle_m) < self.detect_rad)
        #===================

        #===================
        target_distance_n = self._compute_dis(self.target_x - self.usv_x_n, self.target_y - self.usv_y_n)
        target_radian_n = math.atan2(self.target_y - self.usv_y_n, self.target_x - self.usv_x_n)
        ahead_radian_n = random.random() * math.pi * 2

        obstacle_n = [self.detect_rad for a in range(11)]
        is_crash_n = False
        for i, num in zip(range(-5, 6), range(11)):
            usv_ray_x_n = self.usv_x_n + self.usv_radius * math.cos(math.pi / 10.0 * i + ahead_radian_n)
            usv_ray_y_n = self.usv_y_n + self.usv_radius * math.sin(math.pi / 10.0 * i + ahead_radian_n)
            for obstacle_cir, obstalce_rad in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
                cur_dis = self._get_cross_dis(obstacle_cir[0], obstacle_cir[1], obstalce_rad, self.usv_x_n, self.usv_y_n, usv_ray_x_n, usv_ray_y_n)
                obstacle_n[num] = min(obstacle_n[num], cur_dis)
            dynamic_dis = self._get_cross_dis(self.usv_x_m, self.usv_y_m, self.usv_radius, self.usv_x_n, self.usv_y_n, usv_ray_x_n, usv_ray_y_n)
            if dynamic_dis < obstacle_n[num]:
                obstacle_n[num] = dynamic_dis

        is_obstacle_n = bool(min(obstacle_n) < self.detect_rad)
        #===================

        velocity_surge_m, velocity_yaw_m, velocity_surge_n, velocity_yaw_n = 0.0, 0.0, 0.0, 0.0

        self.state = np.array([is_obstacle_m, velocity_surge_m, velocity_yaw_m, target_distance_m, target_radian_m, ahead_radian_m, obstacle_m[0], obstacle_m[1],
        obstacle_m[2], obstacle_m[3], obstacle_m[4], obstacle_m[5], 
        obstacle_m[6], obstacle_m[7], obstacle_m[8], obstacle_m[9], obstacle_m[10], 
        is_obstacle_n, velocity_surge_n, velocity_yaw_n, target_distance_n, target_radian_n, ahead_radian_n, obstacle_n[0], obstacle_n[1], 
        obstacle_n[2], obstacle_n[3], obstacle_n[4], obstacle_n[5],
        obstacle_n[6], obstacle_n[7], obstacle_n[8], obstacle_n[9], obstacle_n[10]])
        return self.state  # np.array(self.state)


    def render(self, mode='human', close=False):
        if close:
            if self.viewer is not None:
                self.viewer.close()
                self.viewer = None
            return

        # 如果还没有设定屏幕对象，则初始化整个屏幕具备的元素。
        if self.viewer is None:
            from gym.envs.classic_control import rendering
            self.viewer = rendering.Viewer(self.width * self.scale, self.height * self.scale)

            # 在Viewer里绘制一个几何图像的步骤如下：
            # 1. 建立该对象需要的数据本身
            # 2. 使用rendering提供的方法返回一个geom对象
            # 3. 对geom对象进行一些对象颜色、线宽、线型、变换属性的设置（有些对象提供一些个
            #    性化的方法
            #    来设置属性，具体请参考继承自这些Geom的对象），这其中有一个重要的属性就是
            #    变换属性，该属性负责对对象在屏幕中的位置、渲染、缩放进行渲染。如果某对象
            #    在呈现时可能发生上述变化，则应建立关于该对象的变换属性。该属性是一个
            #    Transform对象，而一个Transform对象，包括translate、rotate和scale
            #    三个属性，每个属性都由以np.array对象描述的矩阵决定。
            # 4. 将新建立的geom对象添加至viewer的绘制对象列表里，如果在屏幕上只出现一次，
            #    将其加入到add_onegeom(）列表中，如果需要多次渲染，则将其加入add_geom()
            # 5. 在渲染整个viewer之前，对有需要的geom的参数进行修改，修改主要基于该对象
            #    的Transform对象
            # 6. 调用Viewer的render()方法进行绘制

            target = rendering.make_circle(self.usv_radius * self.scale, 30, True)
            target.set_color(178.0 / 255.0, 200.0 / 255.0, 187.0 / 255.0)
            self.viewer.add_geom(target)
            self.target_trans = rendering.Transform()
            target.add_attr(self.target_trans)

            self.agent_m = rendering.make_circle(self.usv_radius * self.scale, 30, True)
            self.agent_m.set_color(222.0 / 255.0, 211.0 / 255.0, 140.0 / 255.0)
            self.viewer.add_geom(self.agent_m)
            self.agent_trans_m = rendering.Transform()
            self.agent_m.add_attr(self.agent_trans_m)

            self.agent_n = rendering.make_circle(self.usv_radius * self.scale, 30, True)
            self.agent_n.set_color(222.0 / 255.0, 211.0 / 255.0, 140.0 / 255.0)
            self.viewer.add_geom(self.agent_n)
            self.agent_trans_n = rendering.Transform()
            self.agent_n.add_attr(self.agent_trans_n)

            for obstacles_pos, radius in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
                obstacle = rendering.make_circle(radius * self.scale, 30, True)
                obstacle.set_color(252.0 / 255.0, 157.0 / 255.0, 154.0 / 255.0)
                self.viewer.add_geom(obstacle)
                self.obstacle_trans = rendering.Transform(translation=(obstacles_pos[0] * self.scale, obstacles_pos[1] * self.scale))
                obstacle.add_attr(self.obstacle_trans)

            
        self.target_trans.set_translation(self.target_x * self.scale, self.target_y * self.scale)
        self.agent_trans_m.set_translation(self.usv_x_m * self.scale, self.usv_y_m * self.scale)
        self.agent_trans_n.set_translation(self.usv_x_n * self.scale, self.usv_y_n * self.scale)
        
        return self.viewer.render(return_rgb_array = mode == 'rgb_array')


if __name__ =="__main__":
    env = AvoidWorldEnv()
    print("hello")
    env.reset()
    nfs = env.observation_space.shape[0]
    nfa = env.action_space
    # print("nfs:%s; nfa:d"%(nfs))
    # print(env.observation_space)
    # print(env.action_space)

    for _ in range(10000):
       env.render()
       s, r, d, _ = env.step(env.action_space.sample())
       if d is True:
           env.reset()

    print("env closed")