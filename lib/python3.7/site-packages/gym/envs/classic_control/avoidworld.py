"""
PuckWorld Environment for OpenAI gym
The data used in this model comes from:
http://cs.stanford.edu/people/karpathy/reinforcejs/puckworld.html
Author: Qiang Ye
Date: July 17, 2017
"""

import math
import gym
from gym import spaces
from gym.utils import seeding
import numpy as np
import random

RAD2DEG = 57.29577951308232     # 弧度与角度换算关系1弧度=57.29..角度
OBSTACLE_POS = [[24.5, 13.5], [22.8, 79.3], [41.4, 37.5], [26.4, 53.3], [70.5, 85.3], [89.2, 70.5], [78.2, 24.5], [69.4, 54.3]]
OBSTACLE_RADIUS = [5, 8 , 9.5, 2.5, 5, 4, 4.5, 6.5]


class AvoidWorldEnv(gym.Env):
    metadata = {
        'render.modes': ['human', 'rgb_array'],
        'video.frames_per_second': 30
        }

    def __init__(self):
        self.width = 100            # 场景宽度 screen width
        self.height = 100           # 场景长度
        self.scale = 4.0
        self.max_surge = 2.0      # max agent velocity along a axis 
        self.max_yaw = 1.5
        self.min_obs_dis = 5.0
        self.max_obs_dis = 10.0
        self.l_unit = 1.0

        # self.lambda_distance = 0.2
        # self.lambda_obstacle = 0.7
        self.usv_x = 15.0
        self.usv_y = 15.0
        self.target_x = 85.0
        self.target_y = 85.0
        
        self.t = 0                  # puck world clock
        self.total_step = 1200
        self.update_time = 100      # time for target randomize its position
        # 作为观察空间每一个特征值的下限
        self.low = np.array([0,                     # 障碍 0 1
                            0,                      # surge 速度
                            -self.max_yaw,          # yaw 速度
                            0,                      # 距离目标距离
                            -math.pi,               # 距离目标角度（船圆心 极坐标）
                            0,                      # 弧度 船头角 （世界坐标）
                            self.min_obs_dis,      # 距离障碍最短距离（含圆心）已经碰撞 5.0
                            -math.pi                # 船为圆心 极坐标
                            ])   
        self.high = np.array([1,       
                            self.max_surge,
                            self.max_yaw,          
                            math.sqrt(2) * self.width,
                            math.pi,    
                            2 * math.pi,    
                            self.max_obs_dis,         # 5 + 5    
                            math.pi,
                            ])   
        self.action_low = np.array([-0.5, -0.5])
        self.action_high = np.array([0.5, 0.5])
        self.reward = 0         # for rendering
        self.action = None      # for rendering
        self.viewer = None
        # 0,1,2,3,4 represent left, right, up, down, -, five moves.
#         self.action_space = spaces.MultiDiscrete([3, 5])  
        self.action_space = spaces.Box(self.action_low, self.action_high, dtype = np.float16)
        # 观察空间由low和high决定
        self.observation_space = spaces.Box(self.low, self.high, dtype = np.float32)    
        self.list_acc_surge = np.linspace(-0.5, 0.5, 3)
        self.list_acc_yaw = np.linspace(-0.5, 0.5, 5)

        self._seed()    # 产生一个随机数种子
        self.reset()

    def _seed(self, seed=None):
        # 产生一个随机化时需要的种子，同时返回一个np_random对象，支持后续的随机化生成操作
        self.np_random, seed = seeding.np_random(seed)  
        return [seed]

    def step(self, action):
        assert self.action_space.contains(action), \
            "%r (%s) invalid" % (action, type(action))
        
        acc_surge, acc_yaw = action[0], action[1]    # action for rendering
        if acc_surge >= -0.5 and acc_surge < -0.5 + 1.0 / 3.0: acc_surge = -0.5
        elif acc_surge >= -0.5 + 1.0 / 3.0 and acc_surge < 0.5 - 1.0 / 3.0: acc_surge = 0.0
        elif acc_surge >= 0.5 - 1.0 / 3.0 and acc_surge <= 0.5: acc_surge = 0.5
        
        if acc_yaw >= -0.5 and acc_yaw < -0.3: acc_yaw = -0.5
        elif acc_yaw >= -0.3 and acc_yaw < -0.1: acc_yaw = -0.25
        elif acc_yaw >= -0.1 and acc_yaw < 0.1: acc_yaw = 0.0
        elif acc_yaw >= 0.1 and acc_yaw < 0.3: acc_yaw = 0.25
        elif acc_yaw >= 0.3 and acc_yaw <= 0.5: acc_yaw = 0.5
            
        # acc_surge = self.list_acc_surge[acc_surge_num]
        # acc_yaw = self.list_acc_yaw[acc_yaw_num]
        is_obstacle, velocity_surge, velocity_yaw, target_distance, target_radian, ahead_radian, obstacle_distance, obstacle_radian = self.state # 获取agent位置，速度，目标位置

        velocity_x = velocity_surge * math.cos(ahead_radian)
        velocity_y = velocity_surge * math.sin(ahead_radian)
        self.usv_x, self.usv_y = self.usv_x + velocity_x, self.usv_y + velocity_y         # update agent position
        ahead_radian = ahead_radian + velocity_yaw
        if ahead_radian < 0.0: ahead_radian = ahead_radian + 2 * math.pi
        if ahead_radian > 2 * math.pi: ahead_radian = ahead_radian - 2 * math.pi

        velocity_surge = velocity_surge + acc_surge
        if velocity_surge < 0.0: velocity_surge = 0.0
        if velocity_surge > self.max_surge: velocity_surge = self.max_surge
        velocity_yaw = velocity_yaw + acc_yaw
        if velocity_yaw < - self.max_yaw: velocity_yaw = - self.max_yaw
        if velocity_yaw > self.max_yaw: velocity_yaw = self.max_yaw
        
        self.t += 1
        # if self.t % self.update_time == 0:  # update target position
        #     tx = self._random_pos()         # randomly
        #     ty = self._random_pos()

        target_distance = self._compute_dis(self.usv_x - self.target_x, self.usv_y - self.target_y)     # agent to target
        target_radian = math.atan2(self.target_y - self.usv_y, self.target_x - self.usv_x)

        obstacle_distance = self.max_obs_dis
        obstacle_radian = math.pi
        is_obstacle = 0.0
        is_crash = False
        for pos in OBSTACLE_POS:
            obs_dis = self._compute_dis(pos[0] - self.usv_x, pos[1] - self.usv_y)
            if obs_dis < obstacle_distance:
                is_obstacle = 1.0
                obstacle_distance = obs_dis
                obstacle_radian = math.atan2(pos[1] - self.usv_y, pos[0] - self.usv_x)
            if obs_dis <= self.min_obs_dis:
                is_crash = True
                
        self.reward = 0.0

        done = bool(target_distance <= self.min_obs_dis or is_crash or self.t > self.total_step)   
        if is_crash:
            self.reward = - 1.0 - target_distance / 15
        if target_distance <= self.min_obs_dis:
            self.reward = 1 + 500 / self.t
        if self.t > self.total_step:
            self.reward = 1 - target_distance / 15
        
        self.state = (is_obstacle, velocity_surge, velocity_yaw, target_distance, target_radian, ahead_radian, obstacle_distance, obstacle_radian)
        return np.array(self.state), self.reward, done, {}

    def _random_pos(self):
        return random.randint(0, self.width), random.randint(0, self.height)

    def _compute_dis(self, dx, dy):
        return math.sqrt(math.pow(dx,2) + math.pow(dy,2))

    def _is_valied(self, cur_x, cur_y, is_target = True):
        if is_target:
            for pos in OBSTACLE_POS:
                if self._compute_dis(pos[0] - cur_x, pos[1] - cur_y) <= 7.0:   # not too close to the obstacle
                    return False
            if self._compute_dis(self.target_x - cur_x, self.target_y - cur_y) <= 7.0:
                return False
            return True
        else:
            for pos in OBSTACLE_POS:
                if self._compute_dis(pos[0] - cur_x, pos[1] - cur_y) <= 7.0:
                    return False
            return True

    def reset(self):
        cur_x, cur_y = self._random_pos()
        while self._is_valied(cur_x, cur_y, False) is not True:
            cur_x, cur_y = self._random_pos()
        self.usv_x, self.usv_y = cur_x, cur_y

        cur_x, cur_y = self._random_pos()
        while self._is_valied(cur_x, cur_y) is not True:
            cur_x, cur_y = self._random_pos()
        self.target_x, self.target_y = cur_x, cur_y
        self.t = 0

        target_distance = self._compute_dis(self.target_x - self.usv_x, self.target_y - self.usv_y)
        target_radian = math.atan2(self.target_y - self.usv_y, self.target_x - self.usv_x)

        obstacle_distance = self.max_obs_dis
        obstacle_radian = math.pi
        is_obstacle = 0.0
        for pos in OBSTACLE_POS:
            obs_dis = self._compute_dis(pos[0] - self.usv_x, pos[1] - self.usv_y)
            if obs_dis < obstacle_distance:
                is_obstacle = 1.0
                obstacle_distance = obs_dis
                obstacle_radian = math.atan2(pos[1]- self.usv_y, pos[0] - self.usv_x)

        self.state = np.array([ is_obstacle,
                                0.0,
                                0.0,
                                target_distance,
                                target_radian,
                                random.random() * 2 * math.pi,
                                obstacle_distance,
                                obstacle_radian
                               ])
        return self.state  # np.array(self.state)


    def render(self, mode='human', close=False):
        if close:
            if self.viewer is not None:
                self.viewer.close()
                self.viewer = None
            return

        # 如果还没有设定屏幕对象，则初始化整个屏幕具备的元素。
        if self.viewer is None:
            from gym.envs.classic_control import rendering
            self.viewer = rendering.Viewer(self.width * self.scale, self.height * self.scale)

            # 在Viewer里绘制一个几何图像的步骤如下：
            # 1. 建立该对象需要的数据本身
            # 2. 使用rendering提供的方法返回一个geom对象
            # 3. 对geom对象进行一些对象颜色、线宽、线型、变换属性的设置（有些对象提供一些个
            #    性化的方法
            #    来设置属性，具体请参考继承自这些Geom的对象），这其中有一个重要的属性就是
            #    变换属性，该属性负责对对象在屏幕中的位置、渲染、缩放进行渲染。如果某对象
            #    在呈现时可能发生上述变化，则应建立关于该对象的变换属性。该属性是一个
            #    Transform对象，而一个Transform对象，包括translate、rotate和scale
            #    三个属性，每个属性都由以np.array对象描述的矩阵决定。
            # 4. 将新建立的geom对象添加至viewer的绘制对象列表里，如果在屏幕上只出现一次，
            #    将其加入到add_onegeom(）列表中，如果需要多次渲染，则将其加入add_geom()
            # 5. 在渲染整个viewer之前，对有需要的geom的参数进行修改，修改主要基于该对象
            #    的Transform对象
            # 6. 调用Viewer的render()方法进行绘制

            target = rendering.make_circle(2.5 * self.scale, 30, True)
            target.set_color(178.0 / 255.0, 200.0 / 255.0, 187.0 / 255.0)
            self.viewer.add_geom(target)
            # target_circle = rendering.make_circle(2.5, 30, False)
            # target_circle.set_color(178.0 / 255.0, 200.0 / 255.0, 187.0 / 255.0)
            # self.viewer.add_geom(target_circle)
            self.target_trans = rendering.Transform()
            target.add_attr(self.target_trans)
            # target_circle.add_attr(self.target_trans)

            self.agent = rendering.make_circle(2.5 * self.scale, 30, True)
            self.agent.set_color(222.0 / 255.0, 211.0 / 255.0, 140.0 / 255.0)
            self.viewer.add_geom(self.agent)
            self.agent_trans = rendering.Transform()
            self.agent.add_attr(self.agent_trans)

            for obstacles_pos, radius in zip(OBSTACLE_POS, OBSTACLE_RADIUS):
                obstacle = rendering.make_circle(radius * self.scale, 30, True)
                obstacle.set_color(252.0 / 255.0, 157.0 / 255.0, 154.0 / 255.0)
                self.viewer.add_geom(obstacle)
                self.obstacle_trans = rendering.Transform(translation=(obstacles_pos[0] * self.scale, obstacles_pos[1] * self.scale))
                obstacle.add_attr(self.obstacle_trans)

            

        # 如果已经为屏幕准备好了要绘制的对象
        # 本例中唯一要做的就是改变小车的位置和旋转
        self.target_trans.set_translation(self.target_x * self.scale, self.target_y * self.scale)
        self.agent_trans.set_translation(self.usv_x * self.scale, self.usv_y * self.scale)
        
        return self.viewer.render(return_rgb_array = mode == 'rgb_array')


if __name__ =="__main__":
    env = AvoidWorldEnv()
    print("hello")
    env.reset()
    nfs = env.observation_space.shape[0]
    nfa = env.action_space
    # print("nfs:%s; nfa:d"%(nfs))
    # print(env.observation_space)
    # print(env.action_space)

    for _ in range(10000):
       env.render()
       s, r, d, _ = env.step(env.action_space.sample())
       if d is True:
           env.reset()

    print("env closed")